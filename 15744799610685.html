<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  TensorFlo优化 - 
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html"></a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>TensorFlow</label></li>

          
            <li><a title="TensorFlo优化" href="15744799610685.html">TensorFlo优化</a></li>
          
            <li><a title="GDG上海 2019.10.13分享内容准备" href="15673444950441.html">GDG上海 2019.10.13分享内容准备</a></li>
          
            <li><a title="Dive Into TensorFlow" href="15659603996762.html">Dive Into TensorFlow</a></li>
          
            <li><a title="Maybe Best Practice With Sparse Machine Learning In TensorFlow" href="15430699092916.html">Maybe Best Practice With Sparse Machine Learning In TensorFlow</a></li>
          

      
        <li class="divider"></li>
        <li><label>机器学习平台</label></li>

          
            <li><a title="机器学习与容器化平台" href="15861773530303.html">机器学习与容器化平台</a></li>
          
            <li><a title="机器学习工程实践" href="15648106167930.html">机器学习工程实践</a></li>
          

      
        <li class="divider"></li>
        <li><label>图计算</label></li>

          
            <li><a title="直播场景PGL落地" href="16078481811620.html">直播场景PGL落地</a></li>
          
            <li><a title="Graph Neural Networks" href="16077533959046.html">Graph Neural Networks</a></li>
          
            <li><a title="graph representation learning" href="16077533959085.html">graph representation learning</a></li>
          
            <li><a title="Spectral Clustering" href="16029890553575.html">Spectral Clustering</a></li>
          
            <li><a title="Community structure in networks" href="16019601035128.html">Community structure in networks</a></li>
          
            <li><a title="Motifs and structural roles in networks" href="16017096445579.html">Motifs and structural roles in networks</a></li>
          
            <li><a title="Snap.py Tutorial: Content" href="16016944212130.html">Snap.py Tutorial: Content</a></li>
          
            <li><a title="Properties of Networks and Random Graph Model" href="16016274752497.html">Properties of Networks and Random Graph Model</a></li>
          

      
        <li class="divider"></li>
        <li><label>pytorch</label></li>

          
            <li><a title="pytorch 环境安装及配置" href="15808187045354.html">pytorch 环境安装及配置</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>TensorFlow</span></li>
                        
                          <li><a title="TensorFlo优化" href="15744799610685.html">TensorFlo优化</a></li>
                        
                          <li><a title="GDG上海 2019.10.13分享内容准备" href="15673444950441.html">GDG上海 2019.10.13分享内容准备</a></li>
                        
                          <li><a title="Dive Into TensorFlow" href="15659603996762.html">Dive Into TensorFlow</a></li>
                        
                          <li><a title="Maybe Best Practice With Sparse Machine Learning In TensorFlow" href="15430699092916.html">Maybe Best Practice With Sparse Machine Learning In TensorFlow</a></li>
                        

                    
                      <li class="side-title"><span>机器学习平台</span></li>
                        
                          <li><a title="机器学习与容器化平台" href="15861773530303.html">机器学习与容器化平台</a></li>
                        
                          <li><a title="机器学习工程实践" href="15648106167930.html">机器学习工程实践</a></li>
                        

                    
                      <li class="side-title"><span>图计算</span></li>
                        
                          <li><a title="直播场景PGL落地" href="16078481811620.html">直播场景PGL落地</a></li>
                        
                          <li><a title="Graph Neural Networks" href="16077533959046.html">Graph Neural Networks</a></li>
                        
                          <li><a title="graph representation learning" href="16077533959085.html">graph representation learning</a></li>
                        
                          <li><a title="Spectral Clustering" href="16029890553575.html">Spectral Clustering</a></li>
                        
                          <li><a title="Community structure in networks" href="16019601035128.html">Community structure in networks</a></li>
                        
                          <li><a title="Motifs and structural roles in networks" href="16017096445579.html">Motifs and structural roles in networks</a></li>
                        
                          <li><a title="Snap.py Tutorial: Content" href="16016944212130.html">Snap.py Tutorial: Content</a></li>
                        
                          <li><a title="Properties of Networks and Random Graph Model" href="16016274752497.html">Properties of Networks and Random Graph Model</a></li>
                        

                    
                      <li class="side-title"><span>pytorch</span></li>
                        
                          <li><a title="pytorch 环境安装及配置" href="15808187045354.html">pytorch 环境安装及配置</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>TensorFlo优化</h1>

<p>这段时间，工作当中杂事比较多，有点像充当产品经理，去给算法业务的同学去安利我们最近完成的一些东西，感觉自己几乎没啥提升，希望这样的日子快点过去，公众号也落下了，主要原因是最近事比较多，又加上还迷上了抖音 什么东北酱，周末一躺就过去了。加上最近网上暴力被裁事情、明星猝死，突然发现中年危机可能就要在眼前，作为最老一批90年后，也马上要30了，但是觉得荒废下去好像也是蛮爽的。哎，迷茫而惆怅的中年危机恐怕是真的要到来了。回到正题，好久没有写过技术文章，最近又开始在读XDL的代码，这次我重点关注在底层，真的觉得质量很高，无愧是阿里妈妈吗的工作，但是无奈基础太差，又加上XDL除了代码开头的license生命几乎没有一行注释， 这里如果有XDL的小伙伴看到，希望把注释补一补，东西是不错，但是也要考虑下我们的水平吧。</p>

<p>本章文章是看到XDL代码之后，发现它自己写了自己的内存管理，这块我之前完全不懂，google一波才明白一些，而TensorFlow本身其实也有一些memory allocation的工作，本章会详细说明下BFC这块的工作。</p>

<h1 id="toc_0">TensorFlow Memory Manage</h1>

<p>BFC是Best fit with coalescing的缩写，下面截图是TensorFlow源码config.proto，其中有关于内存、显存管理的注释文档，BFC是dlmalloc的一个简化版本，DLmalloc是啥，大家不明白没关系，直接理解为内存分配上一个特别硬核的工作，当前很多内存分配的算法很多受其影响。【memory allocate是操作系统下特别复杂的一项工作，如要系统了解，建议读读下OS经典教材memoey manage的几章】。<br/>
<img src="media/15744799610685/15745009823333.jpg" alt=""/></p>

<h2 id="toc_1">TensorFlow Memory Allocator</h2>

<h3 id="toc_2">BFCAllocator</h3>

<p>TensorFlow针对不同的设备，比如cpu下的mkl的allocator，cuda下的allocator，其实现都是有很大的差异的。本文不可能一一详述，仅针对bfc_allocator相关的逻辑进行描述，由于作者在这块经验较少，有任何发现疑问以及问题的请在评论区留言，大家来一起讨论</p>

<h4 id="toc_3">Allocator: Abstract interface for allocating and deallocating device memory</h4>

<pre><code class="language-text">class Allocator {
 public:
  static constexpr size_t kAllocatorAlignment = 64;

  virtual ~Allocator();

  virtual string Name() = 0;

  virtual void* AllocateRaw(size_t alignment, size_t num_bytes) = 0;

  virtual void* AllocateRaw(size_t alignment, size_t num_bytes,
                            const AllocationAttributes&amp; allocation_attr) {
    return AllocateRaw(alignment, num_bytes);
  }

  virtual void DeallocateRaw(void* ptr) = 0;

  virtual size_t RequestedSize(const void* ptr) const {
    CHECK(false) &lt;&lt; &quot;allocator doesn&#39;t track sizes&quot;;
    return size_t(0);
  }

  virtual size_t AllocatedSize(const void* ptr) const {
    return RequestedSize(ptr);
  }

  virtual int64 AllocationId(const void* ptr) const { return 0; }
  virtual size_t AllocatedSizeSlow(const void* ptr) const {
    if (TracksAllocationSizes()) {
      return AllocatedSize(ptr);
    }
    return 0;
  }

  virtual absl::optional&lt;AllocatorStats&gt; GetStats() { return absl::nullopt; }

  virtual void ClearStats() {}

  virtual void SetSafeFrontier(uint64 count) {}
};



struct AllocationAttributes {
  AllocationAttributes() = default;

  AllocationAttributes(bool no_retry_on_failure, bool allocation_will_be_logged,
                       std::function&lt;uint64()&gt;* freed_by_func)
      : no_retry_on_failure(no_retry_on_failure),
        allocation_will_be_logged(allocation_will_be_logged),
        freed_by_func(freed_by_func) {}

  bool no_retry_on_failure = false;
  bool allocation_will_be_logged = false;
  std::function&lt;uint64()&gt;* freed_by_func = nullptr;  // Not owned.

  TF_DISALLOW_COPY_AND_ASSIGN(AllocationAttributes);
};


struct AllocatorStats {
  int64 num_allocs;          // Number of allocations.
  int64 bytes_in_use;        // Number of bytes in use.
  int64 peak_bytes_in_use;   // The peak bytes in use.
  int64 largest_alloc_size;  // The largest single allocation seen.

  absl::optional&lt;int64&gt; bytes_limit;

  int64 bytes_reserved;       // Number of bytes reserved.
  int64 peak_bytes_reserved;  // The peak number of bytes reserved.
  absl::optional&lt;int64&gt; bytes_reservable_limit;

  AllocatorStats()
      : num_allocs(0),
        bytes_in_use(0),
        peak_bytes_in_use(0),
        largest_alloc_size(0),
        bytes_reserved(0),
        peak_bytes_reserved(0) {}

  string DebugString() const;
};
</code></pre>

<p>TensorFlow 内存分配与回收的抽象接口，封装<code>Name</code>, <code>AllocateRaw</code>, <code>DellocateRaw</code>, <code>TracksAllocationSize</code>, <code>AllocatesOpaqueHandle</code>, <code>RequestedSize</code>, <code>AllocatedSize</code>, <code>AllocationId</code>, <code>AllocatedSizeSlow</code>, <code>GetStats</code>, <code>ClearStats</code>, <code>SetSafeFrontier</code>。</p>

<p>这些逻辑作为父类的纯虚接口，由子类去实现，BFCAllocator的详细接口信息如下：<br/>
<img src="media/15744799610685/15750976484848.jpg" alt=""/></p>

<p>在此之前，BFCAllocator下的两个比较重要的数据结构， Chunk和Bin，两者之间的关系如下图，看起来像一个个糖葫芦，第一个bin size为256&lt;<1， 第二个为256<<2, 一次类推，TF内有21个bin，最后bin size 为256 << 21为512MB，每一个bin下面会接下若干个大于bin size的chunk，整个内存空间由以下的结构来组织，当分配内存大小指定时，系统会遍历bin，找到能够第一次满足chunk > bin_size,每一个bin下的chunk是有序的（Bin下的ChunkComparator）<br/>
<img src="media/15744799610685/15750985485415.jpg" alt=""/></p>

<h4 id="toc_4">Chunk</h4>

<p><img src="media/15744799610685/15748482140020.jpg" alt=""/></p>

<pre><code class="language-text">struct Chunk {
    size_t size = 0;
    size_t requested_size = 0;
    int64 allocation_id = -1;
    void* ptr = nullptr;  // pointer to granted subbuffer.
    ChunkHandle prev = kInvalidChunkHandle;
    ChunkHandle next = kInvalidChunkHandle;
    BinNum bin_num = kInvalidBinNum;

    // Optional count when this chunk was most recently made free.
    uint64 freed_at_count = 0;
    bool in_use() const { return allocation_id != -1; }
    string DebugString(BFCAllocator* a,
                       bool recurse) NO_THREAD_SAFETY_ANALYSIS {
      string dbg;
      strings::StrAppend(
          &amp;dbg, &quot;  Size: &quot;, strings::HumanReadableNumBytes(size),
          &quot; | Requested Size: &quot;, strings::HumanReadableNumBytes(requested_size),
          &quot; | in_use: &quot;, in_use(), &quot; | bin_num: &quot;, bin_num);
      if (recurse &amp;&amp; prev != BFCAllocator::kInvalidChunkHandle) {
        Chunk* p = a-&gt;ChunkFromHandle(prev);
        strings::StrAppend(&amp;dbg, &quot;, prev: &quot;, p-&gt;DebugString(a, false));
      }
      if (recurse &amp;&amp; next != BFCAllocator::kInvalidChunkHandle) {
        Chunk* n = a-&gt;ChunkFromHandle(next);
        strings::StrAppend(&amp;dbg, &quot;, next: &quot;, n-&gt;DebugString(a, false));
      }
      return dbg;
    }
  };
</code></pre>

<h4 id="toc_5">Bin</h4>

<p><img src="media/15744799610685/15750983549011.jpg" alt=""/></p>

<pre><code class="language-text">struct Bin {
    // All chunks in this bin have &gt;= bin_size memory.
    size_t bin_size = 0;

    class ChunkComparator {
     public:
      explicit ChunkComparator(BFCAllocator* allocator)
          : allocator_(allocator) {}
      bool operator()(const ChunkHandle ha,
                      const ChunkHandle hb) const NO_THREAD_SAFETY_ANALYSIS {
        const Chunk* a = allocator_-&gt;ChunkFromHandle(ha);
        const Chunk* b = allocator_-&gt;ChunkFromHandle(hb);
        if (a-&gt;size != b-&gt;size) {
          return a-&gt;size &lt; b-&gt;size;
        }
        return a-&gt;ptr &lt; b-&gt;ptr;
      }

     private:
      BFCAllocator* allocator_;  // The parent allocator
    };

    typedef std::set&lt;ChunkHandle, ChunkComparator&gt; FreeChunkSet;

    FreeChunkSet free_chunks;
    Bin(BFCAllocator* allocator, size_t bs)
        : bin_size(bs), free_chunks(ChunkComparator(allocator)) {}
  };
</code></pre>

<h4 id="toc_6">分配内存</h4>

<ul>
<li>rounded_bytes: 保证内存对齐；</li>
<li>BinNumForSize(rounded_bytes):找到对应的BinNum；</li>
<li>MergeTimestampedChunks: 如果timestamped_chunks_不为空， （required_bytes==0,这里还不是特别理解， 有理解清楚的可以在文章后面评论），则合并；</li>
<li>FindChunkPtr:
<ul>
<li>找到第一个满足rounded_bytes的bin；</li>
<li>从free_chunks中删除大于rounded_bytes的chunk， 从free_chunks移除；</li>
<li>若chunk大小为rounded_bytes的两倍,或者chunk大小比rounded_bytes 大128mb以上， 会将chunk split成满足rounded_bytes和剩余大小的chunk, 然后将后者插入合适bin的free_chunks；</li>
</ul></li>
<li>如果FindChunkPtr没找到合适的chunk，则尝试Extend
<ul>
<li>如果available_bytes&lt;rounded_bytes，则返回false；</li>
<li>如果当前curr_region_allocation_bytes_小于rounded_bytes,则curr_region_allocation_bytes翻倍，直到满足大于rounded_bytes;</li>
<li>调用sub_allocator来分配内存块，分配bytes大小为min(rounded_bytes, curr_region_allocation_bytes)， 若未能成功分配，则一直尝试分配0.9*bytes， 若最后也未分配成功，则extend失败；</li>
<li>分配好内存块之后，创建对应的chunk，这个chunk里保存了，内存块地址等信息，并将chunk插入到对应bin；</li>
</ul></li>
<li>如果Extend也fail了， 则再次尝试MergeTimestampedChunks来是否满足round_bytes, （这里会聚合最近释放的内存块，直到满足rounded_bytes）;</li>
<li><p>若再次MergeTimestampedChunks之后还是无法分配合适的内存块，系统会再次尝试释放已经free的regions，然后尝试extend来满足是否能满足分配rounded_Bytes， 如还是fail，则返回空指针，Allocate 失败；</p>
<pre><code class="language-text">void* BFCAllocator::AllocateRawInternal(size_t unused_alignment,
                                        size_t num_bytes,<br/>
                                        bool dump_log_on_failure,<br/>
                                        uint64 freed_before) {<br/>
  if (num_bytes == 0) {<br/>
    VLOG(2) &lt;&lt; &quot;tried to allocate 0 bytes&quot;;<br/>
    return nullptr;<br/>
  }<br/>
  size_t rounded_bytes = RoundedBytes(num_bytes);<br/>
  BinNum bin_num = BinNumForSize(rounded_bytes);<br/>
  mutex_lock l(lock_);<br/>
  if (!timestamped_chunks_.empty()) {<br/>
    MergeTimestampedChunks(0);<br/>
  }<br/>
  void* ptr = FindChunkPtr(bin_num, rounded_bytes, num_bytes, freed_before);<br/>
  if (ptr != nullptr) {<br/>
    return ptr;<br/>
  }<br/>
  if (Extend(unused_alignment, rounded_bytes)) {<br/>
    ptr = FindChunkPtr(bin_num, rounded_bytes, num_bytes, freed_before);<br/>
    if (ptr != nullptr) {<br/>
      return ptr;<br/>
    }<br/>
  }<br/>
  if ((freed_before == 0) &amp;&amp; (!timestamped_chunks_.empty())) {<br/>
    if (MergeTimestampedChunks(rounded_bytes)) {<br/>
      ptr = FindChunkPtr(bin_num, rounded_bytes, num_bytes, freed_before);<br/>
      if (ptr != nullptr) {<br/>
        return ptr;<br/>
      }<br/>
    }<br/>
  }<br/>
  if (DeallocateFreeRegions(rounded_bytes) &amp;&amp;<br/>
      Extend(unused_alignment, rounded_bytes)) {<br/>
    ptr = FindChunkPtr(bin_num, rounded_bytes, num_bytes, freed_before);<br/>
    if (ptr != nullptr) {<br/>
      return ptr;<br/>
    }<br/>
  }
</code></pre></li>
</ul>

<h4 id="toc_7">释放内存</h4>

<ul>
<li>首先，判断ptr是否为空指针，如是，则不作后续操作；</li>
<li>region_manager_.get_handle(ptr) 找到对应chunkhandle, 然后将handle标记为free，具体有application_id赋值为-1， 若timing_counter_为true，则记录释放内存时间；</li>
<li><p>调用InsertFreeChunkIntoBin，将已标记为free的chunk插入到合适的Bin中，释放内存完成；</p>
<pre><code class="language-text">void BFCAllocator::DeallocateRawInternal(void* ptr) {
  if (ptr == nullptr) {<br/>
    VLOG(2) &lt;&lt; &quot;tried to deallocate nullptr&quot;;<br/>
    return;<br/>
  }<br/>
  mutex_lock l(lock_);<br/>
  // Find the chunk from the ptr.<br/>
  BFCAllocator::ChunkHandle h = region_manager_.get_handle(ptr);<br/>
  CHECK(h != kInvalidChunkHandle);<br/>
  MarkFree(h);<br/>
  // Consider coalescing it.<br/>
  if (timing_counter_) {<br/>
    InsertFreeChunkIntoBin(h);<br/>
    timestamped_chunks_.push_back(h);<br/>
  } else {<br/>
    InsertFreeChunkIntoBin(TryToCoalesce(h, false));<br/>
  }<br/>
  if (VLOG_IS_ON(4)) {<br/>
    LOG(INFO) &lt;&lt; &quot;F: &quot; &lt;&lt; RenderOccupancy();<br/>
  }<br/>
}
</code></pre></li>
</ul>

<h4 id="toc_8">读源码的方法</h4>

<p>我发现看懂了一部分代码之后，再写出来就显得很简单，这个对于读者不是什么好事情，很多小伙伴很有心地去阅读某些框架的底层源码，但是很多时候理解不了，下面我分享给小伙伴几个方法：</p>

<ul>
<li>专项学习某些知识点，比如你看的源码部分是memory manager，你可以去找一些国内外教材、教学视频， 先理解清楚其中概念；</li>
<li>至少完整看两遍代码：第一遍，不要嫌麻烦，将每个类的所有的成员函数、成员变量画出来，更给力的是讲类间的关系引用也画出来；第二遍，再逐个函数把逻辑理清楚；</li>
<li>看完之后建议写篇文章来描述下，以后忘记了再稍微看看能搞清楚；</li>
</ul>

<h4 id="toc_9">感兴趣的家庭作业</h4>

<p>XDL代码里面有其他不同的allocator如buddy_allocator, slab_allocator, slab_buddy_allocator，如果有人感兴趣可以按照我前面提的方法来理解下这几块内容，大家一起学习、讨论。</p>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="15808187045354.html"  title="Previous Post: pytorch 环境安装及配置">&laquo; pytorch 环境安装及配置</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="15673444950441.html" 
	        title="Next Post: GDG上海 2019.10.13分享内容准备">GDG上海 2019.10.13分享内容准备 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '15744799610685.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0.4em 0;padding: 0;}
  figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }


</style>
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>


  </body>
</html>
